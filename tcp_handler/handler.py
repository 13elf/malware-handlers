#!/usr/bin/python3


# Author:  Muhammet Ã–ZEN
# Discord: 13elf#9163
# Version: 1.0
# Date:    2021/08/31


import socket
import threading
from typing import Optional
from termcolor import colored
import os
import importlib
import cmd
import time

shellprompt = "hacktheworld"
module_folder = "modules"
next_part = colored(" > ",attrs=["bold"])
modified_prompt = colored(shellprompt,attrs=["bold","underline"])
input_str = modified_prompt + next_part


class Sessions:
    def __init__(self):
        self.session_id = 0
        self.sessions = {}

class Stop:
    def __init__(self):
        self.stop = False

class Module:
    def __init__(self):
        self.handlers = {}
        self.module_object = None
        self.module_str = None

session_obj = Sessions()

st = Stop()
st.stop = False

module = Module()

stop_listening = False


def receive_data(conn,st):
    while True:
        if st.stop == True:
            return
        try:
            conn.settimeout(0.5)
            data = conn.recv(1024)
            data = data.decode("ascii","ignore")
            print(data, end="", flush=True)
        except BrokenPipeError:
            st.stop = True
            print(colored("[*]","blue",attrs=["bold"]), "Session died")
            return
        except socket.timeout:
            pass
        except Exception as e:
            print(colored("[-]","red",attrs=["bold"]), str(e))


def send_data(conn,st):
    while True:
        try:
            send_data_var = (input() + "\n").encode("ascii","ignore")
            if send_data_var.decode()[:-1] in ["bg","background"]:
                print(colored("[*]","blue",attrs=["bold"]), "Backgrounding the session\n")
                st.stop = True
                return
            conn.send(send_data_var)
        except KeyboardInterrupt:
            st.stop = True
            return
        except BrokenPipeError:
            st.stop = True
            print(colored("[*]","blue",attrs=["bold"]), "Session died")
            return

def listen_for_connections(port ,host="0.0.0.0"):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind((host,port))
    s.listen()
    print("\n" + colored("[*]","blue",attrs=["bold"]), "Listening on {0}".format(port))
    try:
        while True:
            (conn, addr) = s.accept()
            session_obj.session_id = session_obj.session_id + 1
            print(colored("[*]","blue",attrs=["bold"]), "Connection received from {0}.".format(str(addr[0]) + ":" + str(addr[1])))
            session_obj.sessions[str(session_obj.session_id)] = (conn,addr)            
    except KeyboardInterrupt:
        print("\n")
        s.close()
        pass

def listen_in_background(port,host="0.0.0.0"):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind((host,port))
    s.listen()
    print("\n" + colored("[*]","blue",attrs=["bold"]), "Listening on {0}".format(port))
    global stop_listening
    stop_listening = False
    try:
        while True:
            try:
                if stop_listening:
                    break
                s.settimeout(2)
                (conn, addr) = s.accept()
            except socket.timeout:
                continue
            session_obj.session_id = session_obj.session_id + 1
            print(colored("[*]","blue",attrs=["bold"]), "Connection received from {0}.".format(str(addr[0]) + ":" + str(addr[1])))
            session_obj.sessions[str(session_obj.session_id)] = (conn,addr)            
    except KeyboardInterrupt:
        print("\n")
        pass

def stop_handler():
    global stop_listening
    stop_listening = True


def list_sessions():
    print("\nSESSIONS\n========\n")
    for i in session_obj.sessions:
        conn, addr = session_obj.sessions[i]
        print(i.ljust(5) + " =>   " + str(addr[0]) + ":" + str(addr[1]))
    print()


def check_connection(key):
    connx,addrx = session_obj.sessions[key]
    try:
        connx.send("\n".encode())
        connx.send("\n".encode())
    except BrokenPipeError as e:
        print(colored("[*]","blue",attrs=["bold"]), "Command shell session {0} has been terminated".format(key))
        c,a = session_obj.sessions[key]
        c.close()
        del session_obj.sessions[key]
        return False
    except ConnectionResetError:
        print(colored("[*]","blue",attrs=["bold"]), "Command shell session {0} has been terminated".format(key))
        c,a = session_obj.sessions[key]
        c.close()
        del session_obj.sessions[key]
        return False
    return True


def eliminate(iterable):
    ret = []
    for i in iterable:
        if i:
            ret.append(i)
    return ret


def get_handlers(foldername="modules", willDisplay=True):
    if willDisplay:
        print("\nAvailable Handlers\n==================\n")
    module.handlers = {}
    
    os.system("cd {0} && ls -l *.py 2>/dev/null | tr -s ' ' | cut -d ' ' -f 9 > output.txt".format(foldername))
    content = ""
    with open("./{0}/output.txt".format(foldername), "r") as f:
        content = f.read()
    os.system("cd {0} && rm output.txt".format(foldername))
    content = content.split("\n")

    lines = []
    for x in content:
        if (x == "") or ("__" in x) or (x == "output.txt"):
            pass
        else:
            lines.append(x.split(".")[0])
    
    index = 2
    module.handlers["1"] = "default"
    if willDisplay:
        print("1".ljust(5) + "default")
    for i in lines:
        if (willDisplay):
            print(str(index).ljust(5) + i)
        module.handlers[str(index)] = i
        index += 1

    if willDisplay:
        print()

    return lines

def use(handler_id):
    for i in module.handlers:
        if i == handler_id or module.handlers[i] == handler_id:
            return module.handlers[i].split(".")[0]
    return None


class Handler(cmd.Cmd):
    module_folder = "modules"
    next_part = colored(" > ",attrs=["bold"])
    modified_prompt = colored(shellprompt,attrs=["bold","underline"])
    prompt = modified_prompt + next_part
    lines = get_handlers(module_folder,willDisplay=False)


    def do_use(self,args: str):
        splitted = eliminate(args.split(" "))
        try:
            ret = use(splitted[0])
        except IndexError:
            print(colored("[*]","blue",attrs=["bold"]),"No module specified")
            return
        if ret == None:
            print(colored("[-]","red",attrs=["bold"]), "Invalid module")
            return
        elif ret.lower() == "default":
            module.module_object = None
            module.module_str = "default"

        else:
            module.module_object = importlib.import_module(module_folder + "." + ret)
            module.module_str = ret
        
        self.prompt = modified_prompt + colored(" (" + module.module_str + ")","blue") + next_part


    def do_modules(self,args):
        get_handlers(module_folder,True)


    def do_exit(self,args):
        exit()


    def do_sessions(self,args: str):
        list_sessions()


    def do_interact(self,args: str):
        splitted = eliminate(args.split(" "))
        try:
            print(colored("[*]","blue",attrs=["bold"]), "Interacting with session {0}\n".format(splitted[0]))
        except IndexError:
            return
        try:
            connx,addrx = session_obj.sessions[splitted[0]]
        except KeyError:
            print(colored("[-]","red",attrs=["bold"]), "Session id {0} is invalid".format(splitted[0]))
            return

        if check_connection(splitted[0]) == False:
            return
        st.stop = False
        if module.module_object != None:
            thread = threading.Thread(target=module.module_object.receive_data,args=(connx,st,))
        else:
            module.module_str = "default"
            print(colored("[*]","blue",attrs=["bold"]),"Using the default handler")
            thread = threading.Thread(target=receive_data,args=(connx,st,))
        thread.start()
        if module.module_object != None:
            module.module_object.send_data(connx,st)
        else:
            send_data(connx,st)
        thread.join()


    def do_listen(self,args: str):
        splitted = eliminate(args.split(" "))
        if len(splitted) == 0:
            return
        if splitted[0] == "-b":
            try:
                threading.Thread(target=listen_in_background,args=(int(splitted[1]),)).start()
            except IndexError:
                print(colored("[-]","red",attrs=["bold"]),"No port specified")
        else:
            try:
                listen_for_connections(int(splitted[0]))
            except IndexError:
                print(colored("[-]","red",attrs=["bold"]),"No port specified")
                
                return
            except Exception as e:
                print(colored("[-]","red",attrs=["bold"]),end=" ")
                print(str(e))

    def do_stop(self, args):
        print(colored("[*]","blue", attrs="bold"), "Stopping all background handler jobs")
        stop_handler()

    def do_kill(self,args: str):
        splitted = eliminate(args.split(" "))
        try:
            if splitted[0] == "all":
                for i in session_obj.sessions:
                    conn_s, addr_s = session_obj.sessions[i]
                    conn_s.send("exit".encode())
                    conn_s.close()
                time.sleep(1)
                session_obj.sessions = {}
            else:
                conn_s,addr_s = session_obj.sessions[splitted[0]]
                conn_s.send("exit".encode())
                conn_s.close()
                time.sleep(1)
                del session_obj.sessions[splitted[0]]
        except IndexError:
            print("Sepicfy a session to kill (ex: 1 / 2 / all ...)")

    def do_clear(self, args):
        answer =input("Are you sure you want to clear the screem? y/n: ")
        try:
            if answer[0].lower() == "y":
                os.system("clear")
        except IndexError:
            pass

    def do_threads(self,args):
        print("Thread count:", threading.active_count())
    

    def do_help(self, arg: str) -> Optional[bool]:
        return super().do_help(arg)


    def help_modules(args):
        print()
        print(">> Display all available handler modules")
        print()


    def help_use(args):
        print()
        print(">> Load a python script as a module to use as a handler")
        print("Syntax: use <module_id or name>")
        print("Sample Usage: use 2 / use windows_advanced")
        print()


    def help_listen(args):
        print()
        print(">> Listen on a port")
        print("Syntax: listen <port>")
        print("Sample Usage: listen 4444")        
        print()


    def help_sessions(args):
        print()
        print(">> Lst all available active sessions")
        print()


    def help_interact(args):
        print()
        print(">> Interact with an active session")
        print("Syntax: interact <session_id>")
        print("Sample Usage: interact 3")
        print()


    def help_kill(args):
        print()
        print(">> Kill a session or all of the sessions")
        print("Syntax: kill <session_id or all>")
        print("Sample Usage: kill 1 / kill 3 / kill all")
        print()


    def help_exit(args):
        print()
        print(">> Exit out of the program")
        print()


    def default(self, line: str) -> bool:
        print(colored("[-]","red",attrs=["bold"]),"Command not defined:", line.split(" ")[0])


    def emptyline(self):
        pass


while True:
    if __name__ == "__main__":
        try:
            Handler().cmdloop()
        except KeyboardInterrupt:
            print("Type exit to quit the program!")
