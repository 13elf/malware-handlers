# Description
This project is coded for handling reverse tcp connections in a penetration test. Project structure is as follows:
  - handler.py
  - modules/
    - example_handler.py
    - other handlers...

Handler.py is the main script of our program which contains all the facilities and functions need to handle and manage an incoming tcp session. We also have modules folder where our customized handlers are located. These customized handlers can be coded in a way to perform tasks like advance shell handling, session backgrounding etc.(More information will be provided below). The framework also supports tab auto-completion.

# How to use it
The main tool has a couple of main features including but not limited to starting foreground and background listeners, switching between sessions, loading different handler modules and killing sessions. Each section is explained below:

## Listening for incoming sessions
The command "listen" is used for binding to a local port for incoming connections. The syntax is the command "listen" followed by the port to listen on. There's also "-b" switch that can be used in conjunction with listen to start the listener in the background so that more than one incoming sessions can be caught at a time.

Sample Usage:
> listen 4444<BR>
> listen -b 4444<BR>

## Stopping background listeners
If one or more listener threads are running in the background, there's a way to stop them all at once. The "stop" command with no arguments will stop any background listener threads that might be running regardless of how many of them there are.

Sample Usage:
> stop

## Displaying and switching between active sessions
The command "sessions" is used to list out all the active sessions caught by our handler along with their session ids. These sessions are a bunch of socket handles stored in a global dictionary variable. In order to interact with one of them, type in the "interact" command followed by the session id. That allows you to drop into the specified shell session.

Sample Usage:
> sessions<BR>
> interact 3<BR>

If you want to leave the current session you are in without shutting it down permanently, press Ctrl + C and it will only terminate the handler threads, not the socket handle itself. That way, you get back to the main program prompt without terminating that particular session. From that point on, you can switch over to any other session you want

## Understanding, displaying and loading modules
When you type in the command "modules", you'll get a list of handler modules available on the framework. No matter what you have in your modules folder, the "default" module should always be there (Don't ever delete the modules folder. Otherwise the program won't run). What default handler module does is it takes any input supplied from the terminal and forwards it to the target shell. "background" and "bg" are the only two commands that are exceptions. They put the session in the background and bring you back to the main prompt. (For most users, the default handlers will be enough. There's mostly no need for external handler modules)

Sample Usage:
> modules<BR>

In order to use a module, type in the command "use" along with the module id that's displayed in the output of "modules" command or follow "use" command by the module name (Type in the name you see in the output of modules command which doesn't contain .py extension). Then you should see the module name in blue parenthesis right next to the main prompt.

Sample Usage:
> use 1<BR>
> use default<BR>

In the modules folder, we can include external handler modules that can be imported to our main script. The reason for including modules is that you may sometimes want to perform different actions based on the input supplied from the attacker's terminal. In these cases, default handler module won't be enough since it only forwards whatever's given to it to the victim. Before you start to write your own handlers, keep in mind that "socket" library should always be imported along with defining send_data(conn,st) and receive_data(conn,st) functions. These definitions are necessary for the module to work properly. (An example module is provided in modules folder with the name example_modules.py)

Both send_data and receive_data functions should take exactly two arguments. First one is conn as seen above which is the socket handle that will be used to communicate with the target session. Second argument is st (short for stop), that is a global object with one property which is stop. Stop is a boolean variable that's been used in handler.py to manage when to terminate the "receive_data" thread. The way it's used is whenever "bg", "background" or Ctrl+C is detected, this global value is set to True. At the same time, the "receive_data" thread checks this value every 0.5 second and if st.stop evaluates to True, it terminates the thread. That way you successfully get back to the main prompt again. (Again, most of the time you don't need to deal with these things. Default handler is enough for most users but the framework enables you to write your own customized handlers)

## Killing sessions
Kill can be used in one of two ways:

> kill all<BR>
> kill 3<BR>

As you may have guessed, "kill all" kills all the sessions by sending "exit" command to the shell session and unloading it's socket handle from the memory. "kill 3" kills the session with id 3 the same way.

## Clearing the screen
Most of the time, it's a habit of a Linux user to clear the screen pretty often. But if you have an important piece of data you received from the shell session and accidentally clear it out, that would be a little problematic. That's why every time you type in the "clear" command, the program asks you if you really want to clear the screen out. If you type in "y", only then the screen gets cleared.

## Exiting the program
Ctrl+C or EOF cannot be used to terminate the program. It's very easy to accidentally press Ctrl+C or Ctrl+D and terminate all the sessions you have on your target. Because of that, the only way to exit out of this program is to manually type exit. Then the program will be terminated along with any possible active shell you might have.

## Getting help
The "help" command displays a basic help screen with available commands. "help" followed by the command name will display more detailed help screen for that spesific command.

## Thread Count
Every time we attach to a session or start a listener that binds to a local port, we create a thread. And the "threads" command displays the number of threads that are running in the program. At the very beginning, it will be 1. That is a debugging feature coded for developers to check if there's any unterminated threads where there should be none.
